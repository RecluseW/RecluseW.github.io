<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vuex详解</title>
      <link href="/2021/09/19/vuex-xiang-jie/"/>
      <url>/2021/09/19/vuex-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="一、-Vuex简介"><a href="#一、-Vuex简介" class="headerlink" title="一、 Vuex简介"></a><strong>一、 Vuex简介</strong></h2><h3 id="1-1-官方解释"><a href="#1-1-官方解释" class="headerlink" title="1.1  官方解释"></a>1.1  官方解释</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><hr><h3 id="1-2-状态管理到底是什么？"><a href="#1-2-状态管理到底是什么？" class="headerlink" title="1.2  状态管理到底是什么？"></a>1.2  状态管理到底是什么？</h3><ul><li><p>状态管理模式、集中式存储管理这些名词听起来就非常高大上，让人捉摸不透。</p></li><li><p>其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</p></li><li><p>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</p></li><li><p>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？</p></li></ul><hr><h3 id="1-3-Vuex状态管理图例"><a href="#1-3-Vuex状态管理图例" class="headerlink" title="1.3   Vuex状态管理图例"></a>1.3   Vuex状态管理图例</h3><p><img src="1.png"></p><hr><hr><h2 id="二、Vuex的基本使用"><a href="#二、Vuex的基本使用" class="headerlink" title="二、Vuex的基本使用"></a><strong>二、Vuex的基本使用</strong></h2><h3 id="2-1-Vuex五个核心概念总概"><a href="#2-1-Vuex五个核心概念总概" class="headerlink" title="2.1  Vuex五个核心概念总概"></a>2.1  Vuex五个核心概念总概</h3><ul><li><strong>state：</strong>Vuex的基本数据，用来存储变量</li><li><strong>getters：</strong>从基本数据(state)派生的数据，相当于state的计算属性</li><li><strong>mutation：</strong>提交更新数据的方法(里面是写方法的)，必须是同步的(如果需要异步使用action)。每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数，提交载荷作为第二个参数。</li><li><strong>actions：</strong>和mutation的功能大致相同，不同之处在于 ==》1. Action 提交的是 mutation，而不是直接变更状态。 2. Action 可以包含任意异步操作。</li><li><strong>modules：</strong>模块化Vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</li></ul><p>注意：    一般在项目的src文件夹中新建store文件夹，Vuex相关代码都写到里面</p><p><strong>案例：</strong></p><p><img src="2.png"></p><hr><h3 id="2-2-state单一状态树"><a href="#2-2-state单一状态树" class="headerlink" title="2.2 state单一状态树"></a>2.2 state单一状态树</h3><h4 id="2-2-1-单一状态树解释："><a href="#2-2-1-单一状态树解释：" class="headerlink" title="2.2.1 单一状态树解释："></a>2.2.1 单一状态树解释：</h4><ul><li>用一个对象（主干）就包含了全部的（分支）应用层级状态</li><li>每个应用将仅仅包含一个 store 实例对象（主干）</li></ul><p>单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><h4 id="2-2-2-如何在-Vue-组件中展示状态呢？"><a href="#2-2-2-如何在-Vue-组件中展示状态呢？" class="headerlink" title="2.2.2 如何在 Vue 组件中展示状态呢？"></a>2.2.2 如何在 Vue 组件中展示状态呢？</h4><p>从store实例中读取状态最简单的方法就是在计算属性中返回某个状态。</p><p>示例：</p><p>例如我们在state中定义一个count属性，给它赋一个值为10，store.js文件内容如下所示：</p><p><img src="3.png"></p><p>然后创建一个 Counter组件，在组件中返回count，内容如下所示：</p><p><img src="4.png"></p><p>每当 store.state.count 变化的时候，都会重新求取count属性，并刷新界面。</p><p>这种模式依赖于全局的管理员 store，如果模块多了，那么每个模块或者页面只要用到了这个 state 里面的数据，都得把 store 引入进来，这样的操作确实有点难受。所以出现了下面这种解决办法。</p><p>Vuex 通过store 选项，提供了一种机制将状态从根组件 “注入” 到每一个子组件中：</p><p><img src="5.png"></p><p>在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过this.$store 访问到，在组件中直接访问:this.$store.state.count</p><h4 id="2-2-3-mapState辅助函数"><a href="#2-2-3-mapState辅助函数" class="headerlink" title="2.2.3 mapState辅助函数"></a>2.2.3 mapState辅助函数</h4><p>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。</p><p>示例：</p><p>在使用mapState函数之前，需要先引入它：import { mapState } from ‘Vuex’</p><p>引入后才可以开始使用，它两种用法，可以接受一个对象或接受一个数组。</p><p>对象用法如下：</p><p><img src="6.png"></p><p>数组用法如下所示：</p><p><img src="7.png"></p><hr><h3 id="2-3-getters"><a href="#2-3-getters" class="headerlink" title="2.3  getters"></a>2.3  getters</h3><h4 id="2-3-1-前言"><a href="#2-3-1-前言" class="headerlink" title="2.3.1  前言"></a>2.3.1  前言</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getter 接受 state 作为其第一个参数：</p><p><img src="8.png"></p><h4 id="2-3-2-通过属性访问"><a href="#2-3-2-通过属性访问" class="headerlink" title="2.3.2  通过属性访问"></a><strong>2.3.2</strong>  通过属性访问</h4><p>Getter会暴露为 store.getters 对象，你可以以属性的形式访问这些值：</p><p><strong>store.getters.doneTodos //  [{ id: 1, text: ‘…’, done: true }]</strong></p><p>Getter 也可以接受其他 getter 作为第二个参数：</p><p><img src="9.png"></p><p>我们可以很容易地在任何组件中使用它：</p><p><img src="10.png"></p><p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p><h4 id="2-3-3-通过方法访问"><a href="#2-3-3-通过方法访问" class="headerlink" title="2.3.3  通过方法访问"></a><strong>2.3.3</strong>  通过方法访问</h4><p>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p><p><img src="11.png"></p><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p><h4 id="2-3-4-案例：获取学生年龄大于20的个数"><a href="#2-3-4-案例：获取学生年龄大于20的个数" class="headerlink" title="2.3.4  案例：获取学生年龄大于20的个数"></a>2.3.4  案例：获取学生年龄大于20的个数</h4><p><img src="12.png"></p><p>注意：getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</p><hr><h3 id="2-4-mutations"><a href="#2-4-mutations" class="headerlink" title="2.4  mutations"></a>2.4  mutations</h3><h4 id="2-4-1-Mutation状态更新"><a href="#2-4-1-Mutation状态更新" class="headerlink" title="2.4.1  Mutation状态更新"></a>2.4.1  Mutation状态更新</h4><p>Vuex的store状态的更新唯一方式：提交Mutation</p><p>Mutation主要包括两部分：</p><ul><li>字符串的事件类型（type）</li><li>一个回调函数（handler）,该回调函数的第一个参数就是state</li></ul><p>mutation的定义方式：</p><p><img src="13.png"></p><p>通过mutation更新：</p><p><img src="14.png"></p><h4 id="2-4-2-Mutation传递参数"><a href="#2-4-2-Mutation传递参数" class="headerlink" title="2.4.2 Mutation传递参数"></a>2.4.2 Mutation传递参数</h4><p>在通过mutation更新数据的时候, 有可能我们希望携带一些额外的参数</p><ul><li>参数被称为是mutation的载荷(Payload)</li></ul><p>Mutation中的代码:</p><p><img src="15.png"></p><p>但是如果参数不是一个呢?</p><ul><li>比如我们有很多参数需要传递.</li><li>这个时候, 我们通常会以对象的形式传递, 也就是payload是一个对象.</li><li>这个时候可以再从对象中取出相关的信息.</li></ul><p><img src="16.png"></p><p><strong>案例：</strong>使+5按钮和+10按钮起效果，点击添加学生就给stu信息添加到数组中</p><p><img src="17.png"></p><h4 id="2-4-3-Mutation另一种提交风格"><a href="#2-4-3-Mutation另一种提交风格" class="headerlink" title="2.4.3  Mutation另一种提交风格"></a>2.4.3  Mutation另一种提交风格</h4><p>上面的通过commit进行提交是一种普通的方式,Vue还提供了另外一种风格, 它是一个包含type属性的对象</p><p><img src="18.png"></p><p>Mutation中的处理方式是将整个commit的对象作为payload使用, 所以代码没有改变, 依然如下:</p><p><img src="19.png"></p><h4 id="2-4-4-Mutation响应规则"><a href="#2-4-4-Mutation响应规则" class="headerlink" title="2.4.4  Mutation响应规则"></a>2.4.4  Mutation响应规则</h4><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</p><ul><li>state里面的内容属性都会被添加到响应式系统中，当系统监听到属性发生了变化，就会通知所有界面中用到该属性的地方进行更新，页面就会刷新</li></ul><p>这就要求我们必须遵守一些Vuex对应的规则：</p><ul><li><p>提前在store中初始化好所需的属性.</p></li><li><p>当给state中的对象添加新属性时, 使用下面的方式:</p></li><li><ul><li>方式一: 使用Vue.set(obj, ‘newProp’, 123)</li><li>方式二: 用新对象给旧对象重新赋值</li></ul></li></ul><p>我们来看一个例子:</p><ul><li>当我们点击更新信息时, 界面并没有发生对应改变.</li></ul><p><img src="20.png"></p><p>如何才能让它改变呢?</p><ul><li>查看下面代码的方式一和方式二</li><li>都可以让state中的属性是响应式的.</li></ul><p><img src="21.png"></p><h4 id="2-4-5-使用Mutation常量类型"><a href="#2-4-5-使用Mutation常量类型" class="headerlink" title="2.4.5  使用Mutation常量类型"></a>2.4.5  使用Mutation常量类型</h4><p>我们来考虑下面的问题:</p><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称).</li><li>当我们的项目增大时, Vuex管理的状态越来越多, 需要更新状态的情况越来越多, 那么意味着Mutation中的方法越来越多.</li><li>方法过多, 使用者需要花费大量的经历去记住这些方法, 甚至是多个文件间来回切换, 查看方法名称, 甚至如果不是复制的时候, 可能还会出现写错的情况.</li></ul><p>如何避免上述的问题呢?</p><ul><li>在各种Flux实现中, 一种很常见的方案就是使用常量替代Mutation事件的类型.</li><li>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型一目了然.</li></ul><p>具体怎么做呢?</p><ul><li>我们可以创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</li><li>定义常量时, 我们可以使用ES2015中的风格, 使用一个常量来作为函数的名称.</li></ul><p><img src="22.png"></p><h4 id="2-4-6-Mutation同步函数"><a href="#2-4-6-Mutation同步函数" class="headerlink" title="2.4.6  Mutation同步函数"></a>2.4.6  Mutation同步函数</h4><p>通常情况下, Vuex要求我们<strong>Mutation中的方法必须是同步方法.</strong></p><ul><li>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.</li><li>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.</li></ul><p>比如我们之前的代码, 当执行更新时, devtools中会有如下信息: 图1</p><p><img src="23.png"></p><p>但是, 如果Vuex中的代码, 我们使用了异步函数(定时器): 图2</p><p><img src="24.png"></p><p>你会发现state中的info数据一直没有被改变, 因为他无法追踪到，所以通常情况下, 不要再mutation中进行异步的操作</p><hr><h3 id="2-5-actions"><a href="#2-5-actions" class="headerlink" title="2.5  actions"></a>2.5  actions</h3><h4 id="2-5-1-Action的基本定义"><a href="#2-5-1-Action的基本定义" class="headerlink" title="2.5.1  Action的基本定义"></a>2.5.1  Action的基本定义</h4><p>我们强调, 不要再Mutation中进行异步操作.</p><ul><li>但是某些情况, 我们确实希望在Vuex中进行一些异步操作, 比如网络请求, 必然是异步的. 这个时候怎么处理呢?</li><li><strong>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</strong></li><li>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用context.commit提交一个 mutation，或者通过context.state和context.getters来获取 state 和 getters。</li></ul><p>让我们来注册一个简单的 action：</p><p><img src="25.png"></p><p>context是什么?</p><ul><li>context是和store对象具有相同方法和属性的对象.</li><li>也就是说, 我们可以通过context去进行commit相关的操作, 也可以获取context.state等.</li><li>但是注意, 这里它们并不是同一个对象, 为什么呢? 我们后面学习Modules的时候, 再具体说.</li></ul><p>这样的代码是否多此一举呢?</p><ul><li>我们定义了actions, 然后又在actions中去进行commit, 这不是脱裤放屁吗?</li><li>事实上并不是这样, 如果在Vuex中有异步操作, 那么我们就可以在actions中完成了.</li></ul><h4 id="2-5-2-Action的分发"><a href="#2-5-2-Action的分发" class="headerlink" title="2.5.2 Action的分发"></a>2.5.2 Action的分发</h4><ul><li>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用<strong>store.dispatch()</strong> 方法</li><li>同样的, 也是支持传递<strong>payload</strong></li></ul><p><img src="26.png"></p><h4 id="2-5-3-Action返回的Promise"><a href="#2-5-3-Action返回的Promise" class="headerlink" title="2.5.3 Action返回的Promise"></a>2.5.3 Action返回的Promise</h4><p>前面我们学习ES6语法的时候说过, Promise经常用于异步操作.</p><p>在Action中, 我们可以将异步操作放在一个Promise中, 并且在成功或者失败后, 调用对应的resolve或reject.</p><p><img src="27.png"></p><hr><h3 id="2-6-modules"><a href="#2-6-modules" class="headerlink" title="2.6 modules"></a>2.6 modules</h3><p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p><ul><li>Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.</li><li>当应用变得非常复杂时,store对象就有可能变得相当臃肿.</li><li>为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</li></ul><p>上面的代码中, 我们已经有了整体的组织结构, 下面我们来看看具体的局部模块中的代码如何书写？</p><ul><li>我们在moduleA中添加state、mutations、getters</li><li>mutation和getters接收的第一个参数是局部状态对象</li></ul><p><img src="28.png"></p><p><strong>补充：</strong></p><p>modules里面action的写法: 局部状态通过 context.state 暴露出来，根节点状态则为context.rootState</p><p><img src="29.png"></p><p>modules里如果getters中也需要使用全局的状态, 可以接受更多的参数:</p><p><img src="30.png"></p><hr><hr><h2 id="三、结语"><a href="#三、结语" class="headerlink" title="三、结语"></a>三、结语</h2><p>这是本人在学习vuex时的笔记总结，对vuex进行了简单的概述，并附上了对应的案例，有什么问题希望大家指正！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年最全搭建+美化+使用博客教程</title>
      <link href="/2021/08/12/blog-setup/"/>
      <url>/2021/08/12/blog-setup/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建过程（采用hexo框架-部署到github）"><a href="#博客搭建过程（采用hexo框架-部署到github）" class="headerlink" title="博客搭建过程（采用hexo框架+部署到github）"></a><strong>博客搭建过程（采用hexo框架+部署到github）</strong></h1><h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a><strong>1.前期准备</strong></h2><h3 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a><strong>1.1 注意事项</strong></h3><ul><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导</li><li>hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的</li></ul><h3 id="1-2-下载并安装node-js"><a href="#1-2-下载并安装node-js" class="headerlink" title="1.2 下载并安装node.js"></a><strong>1.2 下载并安装node.js</strong></h3><ul><li>官网下载：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></li><li>安装与使用：见node笔记</li><li>安装后验证：<strong>node -v</strong></li></ul><h3 id="1-3-下载并安装git"><a href="#1-3-下载并安装git" class="headerlink" title="1.3 下载并安装git"></a><strong>1.3 下载并安装git</strong></h3><ul><li>官网下载:  <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></li><li>安装与使用：见git笔记</li><li>安装后验证：<strong>git -v</strong></li></ul><h3 id="1-4-命令行安装cnpm"><a href="#1-4-命令行安装cnpm" class="headerlink" title="1.4 命令行安装cnpm"></a><strong>1.4 命令行安装cnpm</strong></h3><ul><li>命令：<strong>npm install -g cnpm –registry==<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></strong></li><li>安装后验证：<strong>cnpm -v</strong></li></ul><h3 id="1-5-命令行安装hexo"><a href="#1-5-命令行安装hexo" class="headerlink" title="1.5 命令行安装hexo"></a><strong>1.5 命令行安装hexo</strong></h3><ul><li>命令：<strong>cnpm install -g hexo-cli</strong></li><li>安装后验证：<strong>hexo  -v</strong></li></ul><hr><h2 id="2-配置github"><a href="#2-配置github" class="headerlink" title="2.配置github"></a><strong>2.配置github</strong></h2><h3 id="2-1-在github上创建仓库"><a href="#2-1-在github上创建仓库" class="headerlink" title="2.1 在github上创建仓库"></a><strong>2.1 在github上创建仓库</strong></h3><p><strong>创建：</strong></p><ul><li>新建一个名为你的用户名.github.io的仓库</li><li>比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/">http://test.github.io</a> 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</li></ul><p><strong>注意：</strong></p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：username.github.io，其中username是你的用户名；</li><li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</li><li>创建页面如下：</li></ol><p><img src="1.png"></p><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h3 id="2-2-绑定域名（这步可省略）"><a href="#2-2-绑定域名（这步可省略）" class="headerlink" title="2.2 绑定域名（这步可省略）"></a><strong>2.2 绑定域名（这步可省略）</strong></h3><p>当然，你不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p><p>首先你要注册一个域名，域名注册以前总是推荐去godaddy，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！</p><p>绑定域名分2种情况：带www和不带www的。</p><p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问，如下：</p><p><img src="2.png"></p><p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p><ul><li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/">http://www.mygit.me</a> 还是 <a href="http://mygit.me/">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/">http://mygit.me</a></li><li>如果你填写的是带www的，比如 <a href="http://www.mygit.me/">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/">http://www.mygit.me</a> 还是 <a href="http://mygit.me/">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/">http://www.mygit.me</a></li><li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/">http://abc.mygit.me</a></li></ul><p>另外说一句，在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。</p><hr><h2 id="3-配置SSH免密登录"><a href="#3-配置SSH免密登录" class="headerlink" title="3. 配置SSH免密登录"></a><strong>3. 配置SSH免密登录</strong></h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><p><strong>操作步骤：</strong></p><p><strong>第一步：</strong>首先打开电脑文件夹，找到C:\Users\你的用户名.ssh文件夹并删除</p><p><strong>第二步：</strong>在C:\Users\你的用户名 文件夹下右键打开Git Bash Here<strong>输入命令：</strong>ssh-keygen -t rsa -C github邮件地址   生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功</p><p><img src="3.png"></p><p><strong>第三步：</strong>最终生成了一个新的 C:\Users\你的用户名.ssh文件夹，打开这个文件夹，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容</p><p><strong>第四步：</strong>打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图。</p><p><img src="4.png"></p><p><strong>第五步：检测是否设置成功：</strong></p><p>输入命令：  $ ssh -T <a href="mailto:git@github.com">git@github.com</a> # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p><p><strong>第六步：此时你还需要配置：</strong></p><p>$ git config –global user.name “liuxianan”// 你的github用户名，非昵称 $ git config –global user.email  “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“// 填写你的github注册邮箱</p><p>具体这个配置是干嘛的我没仔细深究。</p><hr><h2 id="4-使用-hexo-搭建博客"><a href="#4-使用-hexo-搭建博客" class="headerlink" title="4.使用 hexo 搭建博客"></a><strong>4.使用 hexo 搭建博客</strong></h2><h3 id="4-1-初始化"><a href="#4-1-初始化" class="headerlink" title="4.1 初始化"></a><strong>4.1 初始化</strong></h3><p><strong>第一步：</strong>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是E:\xpzsData\hexocode，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p><p><strong>第二步：</strong>在E:\xpzsData\hexocode文件夹下右键打开 Git Bash Here，输入hexo init 初始化</p><ul><li>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</li></ul><p><img src="5.png"></p><p><strong>第三步：</strong>执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="6.png"></p><p><strong>第四步：</strong>hexo s 是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">https://www.runoob.com/w3cnote/windows-finds-port-usage.html</a></p><ul><li>到这里初始化就完成了</li></ul><h3 id="4-2-将博客部署到-github-个人主页上"><a href="#4-2-将博客部署到-github-个人主页上" class="headerlink" title="4.2 将博客部署到 github 个人主页上"></a><strong>4.2 将博客部署到 github 个人主页上</strong></h3><p><strong>第一步：</strong>在E:\xpzsData\hexocode目录下安装 hexo-deployer-git 插件</p><ul><li><strong>安装命令：</strong> npm install hexo-deployer-git –save  </li><li>必须安装，否则执行hexo d 的话会报如下错误：</li></ul><p><img src="7.png"></p><p><strong>第二步：</strong>编辑E:\xpzsData\hexocode目录下的 _config.yml 文件, 在文件末尾添加如下内容：</p><p><img src="8.png"></p><ul><li>注意：其中 repo 中的内容即为 github 个人主页链接地址，具体看下图：</li></ul><p><img src="9.png"></p><p><strong>第三步：</strong>在E:\xpzsData\hexocode目录下, <strong>输入命令：hexo d</strong> 将本地 blog 推送到 github仓库, 也可能需要输入 username &amp; pwd。</p><ul><li>推送成功后, 在浏览器中输入对应域名, 即可访问 <a href="https://reclusew.github.io/">https://reclusew.github.io/</a></li></ul><hr><h2 id="5-更换主题"><a href="#5-更换主题" class="headerlink" title="5. 更换主题"></a><strong>5. 更换主题</strong></h2><h3 id="5-1-寻找主题"><a href="#5-1-寻找主题" class="headerlink" title="5.1 寻找主题"></a><strong>5.1 寻找主题</strong></h3><ul><li>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</li><li>这是hexo官网：<a href="https://hexo.io/themes/%EF%BC%8C%E5%8F%AF%E5%9C%A8%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E4%B8%BB%E9%A2%98%EF%BC%8C%E7%82%B9%E5%87%BB%E4%B8%BB%E9%A2%98%E5%90%8D%E5%8D%B3%E5%8F%AF%E8%B7%B3%E8%BD%AC%E5%88%B0github%E4%B8%8A%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%9C%A8github%E4%B8%8A%E6%90%9C%E7%B4%A2%E4%B8%BB%E9%A2%98">https://hexo.io/themes/，可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</a></li><li>在这里我使用github上一个大佬的主题blinkfox/hexo-theme-matery</li></ul><p>​              链接：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a>    </p><h3 id="5-2-下载主题"><a href="#5-2-下载主题" class="headerlink" title="5.2 下载主题"></a><strong>5.2 下载主题</strong></h3><p><strong>第一步：</strong>Git Bash Here中先cd到E:\xpzsData\hexocode目录</p><p><strong>第二步：</strong>再输入命令 $ git clone 主题http链接  themes/主题名称</p><p><img src="10.png"></p><p><strong>注意：</strong></p><ul><li>E:\xpzsData\hexocode目录下的 theme 文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看：</li></ul><p><img src="11.png"></p><h3 id="5-3-使用主题"><a href="#5-3-使用主题" class="headerlink" title="5.3 使用主题"></a><strong>5.3 使用主题</strong></h3><ul><li>打开E:\xpzsData\hexocode目录下的_config.yml文件，在里面找到theme: landscape改为theme: blinkfox   （blinkfox为我们要使用的主题名）,然后重新执行hexo g来重新生成。</li><li>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布。</li><li>再次在浏览器中输入对应域名, 即可发现主题已更换</li></ul><p><img src="12.png"></p><h3 id="5-4-修改主题内容"><a href="#5-4-修改主题内容" class="headerlink" title="5.4 修改主题内容"></a><strong>5.4 修改主题内容</strong></h3><p>在这里我使用的是blinkfox主题，后期相关修改参考这个主题文档</p><p><strong>文档链接：</strong><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><ul><li>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的</li><li>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexocode根目录右键打开Git Bash Here，输入两个命令：hexo g 重新生成，hexo s 开启本地预览服务,等修改的符合要求了，再输入 hexo d 推送到github仓库即可</li><li>这样就可以输入网址查看更改后的内容了</li></ul><p><img src="13.png"></p><p><strong>文档上没有提及的修改：</strong></p><ul><li>返回按钮样式修改：在主题下面的 blinkfox\layout_partial 文件夹中的 back-top.esj 文件中修改</li></ul><p><strong>特别注意：</strong></p><ul><li><strong>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的_config.yml文件</strong></li></ul><p><img src="14.png"></p><ul><li><strong>要把根目录下的_config.yml文件中的这些信息替换成自己的和设置中文</strong></li></ul><p><img src="15.png"></p><h3 id="5-5-blinkfox主题的相关配置问题"><a href="#5-5-blinkfox主题的相关配置问题" class="headerlink" title="5.5 blinkfox主题的相关配置问题"></a><strong>5.5 blinkfox主题的相关配置问题</strong></h3><p><strong>配置音乐播放器：</strong>使用网易云音乐id不行，这里用的是QQ音乐</p><p><strong>配置留言功能（利用Valine）：</strong></p><ul><li>我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</li><li>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey，复制到主题下面的 _config.yml 文件里面搜索 valine，填入appid 和 appkey</li><li>最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去就可以了</li><li>主题页面显示的内容在主题下面的 layout 文件夹中的 contact.ejs 文件里面更改</li></ul><hr><h2 id="6-利用Typora软件来写博客"><a href="#6-利用Typora软件来写博客" class="headerlink" title="6.利用Typora软件来写博客"></a><strong>6.利用Typora软件来写博客</strong></h2><h3 id="6-1-Typora介绍"><a href="#6-1-Typora介绍" class="headerlink" title="6.1 Typora介绍"></a><strong>6.1 Typora介绍</strong></h3><ul><li>Typora–一款简单高效的Markdown编辑器，保存后直接为md格式，Markdown中点击导入就可以。</li><li>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，说人话就是删减版的HTML语言</li><li>Markdown教程：<a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></li></ul><h3 id="6-2-安装Typora"><a href="#6-2-安装Typora" class="headerlink" title="6.2 安装Typora"></a><strong>6.2 安装Typora</strong></h3><p><strong>官网：</strong><a href="https://www.typora.io/#windows">https://www.typora.io/#windows</a></p><h3 id="6-3-写博客的步骤"><a href="#6-3-写博客的步骤" class="headerlink" title="6.3  写博客的步骤"></a><strong>6.3  写博客的步骤</strong></h3><p><strong>第一步：创建.md文件</strong></p><ul><li><strong>方法1：</strong>定位到我们的hexo根目录，Git Bash Here 中执行命令：  hexo new ‘my-first-blog’                hexo会帮我们在E:\xpzsData\hexocode\source_posts 下生成相关.md文件，用这个命令的好处是帮我们自动生成了时间，方法1默认生成如下内容：</li></ul><p><img src="16.png"></p><ul><li><strong>方法2：</strong>当然你也可以直接自己打开E:\xpzsData\hexocode\source_posts 目录新建.md文件</li></ul><p><strong>第二步：编写并保存</strong></p><p>我们只需要用typora打开这个文件就可以开始写博客了，写完后Ctrl+S 保存关闭即可</p><p><strong>第三步：</strong>清理然后再生成一下，生成后推送到远程仓库即可，hexo根目录下右键Git Bash Here 中依次输入如下命令：</p><ol><li>hexo clean</li><li>hexo g </li><li>hexo d </li></ol><p><strong>补充：</strong>hexo new page ‘postName’命令和hexo new ‘postName’的区别？</p><ul><li>hexo new page ‘My-second-blog’最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。</li></ul><h3 id="6-4-Typora快捷键"><a href="#6-4-Typora快捷键" class="headerlink" title="6.4  Typora快捷键"></a><strong>6.4  Typora快捷键</strong></h3><p>Typora中只要记住一些基本的快捷键就可以了，所有功能软件里面都有对应按钮，这点不用慌。</p><p><strong>快捷键文章：</strong><a href="https://blog.csdn.net/weixin_39533052/article/details/111115263">https://blog.csdn.net/weixin_39533052/article/details/111115263</a></p><h3 id="6-5-注意：所使用的主题的文章-Front-matter-语法"><a href="#6-5-注意：所使用的主题的文章-Front-matter-语法" class="headerlink" title="6.5  注意：所使用的主题的文章 Front-matter 语法"></a><strong>6.5  注意：所使用的主题的文章 Front-matter 语法</strong></h3><p>依据使用的不同主题，一些文章功能所使用的语法可能不一样，例如写博客时给文章添加标签的语法等等，这些都要看所使用的主题的文档，例如我们这里使用的是 <strong>blinkfox</strong> 主题，打开主题文档，往下翻找到**”**  **文章 Front-matter 介绍 “**即可。</p><p><strong>blinkfox主题文档：</strong><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D</a></p><p><img src="17.png"></p><p><strong>示例：</strong></p><p><img src="18.png"></p><h3 id="6-6-YAML语法（了解）"><a href="#6-6-YAML语法（了解）" class="headerlink" title="6.6 YAML语法（了解）"></a><strong>6.6 YAML语法（了解）</strong></h3><p>像在typora中添加tags时，可以直接用数组的写法，也可以使用YAML语法，如下：</p><p><img src="19.png"></p><p><strong>YAML教程链接：</strong><a href="https://www.runoob.com/w3cnote/yaml-intro.html">https://www.runoob.com/w3cnote/yaml-intro.html</a></p><hr><h2 id="7-如何向hexo博客中插入图片"><a href="#7-如何向hexo博客中插入图片" class="headerlink" title="7.如何向hexo博客中插入图片"></a><strong>7.如何向hexo博客中插入图片</strong></h2><h3 id="7-1-使用相对路径的方式"><a href="#7-1-使用相对路径的方式" class="headerlink" title="7.1 使用相对路径的方式"></a><strong>7.1 使用相对路径的方式</strong></h3><p>众所周知，在md文件中插入图片的语法为!/<a href=""></a>。</p><p>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。</p><p>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。</p><p>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。</p><p>这种方式十分的方便，但是也存在一定的问题：</p><ul><li>图片失效导致无法加载；</li><li>打开网页后要再请求加载图片；</li><li>原网站限制，如微信公众号的图片会变得不可见等。</li></ul><p>这种方式算是有利有弊。</p><p>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。</p><p>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。</p><p>在hexo中使用<strong>文章资源文件夹</strong>需要在config.yaml文件中更改一下配置：</p><p>post_asset_folder: true</p><p>当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p><p><img src="replenish1.jpg"></p><p>虽然可以正常引用图片了，但是这种引用图片的方式只有一句话能形容，wtf。</p><h3 id="7-2-hexo-renderer-marked插件的安装与配置"><a href="#7-2-hexo-renderer-marked插件的安装与配置" class="headerlink" title="7.2 hexo-renderer-marked插件的安装与配置"></a><strong>7.2 hexo-renderer-marked插件的安装与配置</strong></h3><p>插件<a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>解决了这个问题</p><p><strong>安装：</strong> npm install hexo-renderer-marked –save   ，之后在config.yaml中更改配置如下：</p><p><img src="20.png"></p><p>之后就可以愉快的插入图片了</p><h3 id="7-3-hexo-renderer-marked插件与Typora的完美结合"><a href="#7-3-hexo-renderer-marked插件与Typora的完美结合" class="headerlink" title="7.3 hexo-renderer-marked插件与Typora的完美结合"></a><strong>7.3 hexo-renderer-marked插件与Typora的完美结合</strong></h3><p>如果图片数量众多的话，一张一张的放很影响效率。但是不用怕，我们有很方便的解决方法。</p><p><strong>Typora</strong>是我非常喜欢的Markdown文本编辑器，在之前的文章中也介绍过一点。</p><p>Typora对于插入图片的支持做得非常好，在文件-&gt;偏好设置或者直接&lt;C-,&gt;进入设置。</p><p><img src="21.png"></p><p><strong>复制网络路径的图片：</strong></p><p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p><p>如复制网络路径的图片https://…../image.jpg粘贴到Typora中叫文章名的文章后，图片会自动变为(文章名/image.jpg)。</p><p>但我们知道部署后，文件路径是不同的，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的文件名/。不慌，也很简单。</p><p>在Typora编辑器中，使用<c-f>快捷键，将所有的文章名/替换为空即可删除。</c-f></p><p><img src="22.png"></p><p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成</p><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h2><p>这是本人搭建博客过程中遇到的一些问题和解决办法，按照我这个步骤基本就能搭建起来一个不错的博客了，文章里面省略了博客的SEO优化，比如让百度和谷歌搜索引擎收录我们的博客网站，这点大家可以去网上搜索，教程很多的，有什么问题欢迎在下方留言！</p><p>参考文献：</p><p>1：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>2：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p><p>3：<a href="https://www.jianshu.com/p/f72aaad7b852">https://www.jianshu.com/p/f72aaad7b852</a></p>]]></content>
      
      
      <categories>
          
          <category> 综合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/2021/08/11/hello-world/"/>
      <url>/2021/08/11/hello-world/</url>
      
        <content type="html"><![CDATA[<center>大家好，这是我的第一篇博客，本人是前端小萌新一枚，后期会把自己学习路上遇到的问题和笔记写到我的博客里面，欢迎大家访问交流，共同进步！</center><p><img src="2.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
